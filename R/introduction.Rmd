An introduction to the firehose & R
======================================

Twitter contains an enormous amount of data.  Millions of tweets are generated every day on thousands of topics.  They include personal messages, critical information, political statements, humor and images.

We can use this information to help make sense of the world around us if we ask the right questions, use the right tools, and understand a bit about the system we are trying to study.  In this way data science is no different from any of the other sciences.  We need to understand something about the data before we can make sense of it.  In some ways using twitter lowers the barrier because twitter users are not paramecium, rare-earth metals or neutron stars, they are our friends, relatives and neighbors.

To begin to use Twitter as a data source we need to find a way to interact with the program ([http://twitter.com]()) and a way to modify and present the data.  The statistical software R is rapidly becoming popular in the sciences, and people who can use R with some competence are highly valued in the workforce.  One of the benefits of R is that it is incredibly flexible.  

The program itself has a set of basic functions that can be used to do some simple analysis, like take the mean of a set of values:

```{r}
values <- c(10, 20, 30, 40, 50)
mean(values)
```

Here we have created a vector of values by 'concatenating' using the function `c`.  After this we take our variable (a set of numbers) and use it in the function `mean`.

With R we can do all sorts of simple 'scripting', where we enter variables manually and examine them, for example we can use a more complex data structre, called a `data.frame` to look at the differences between red and white cars:

```{r}
car.speeds <- data.frame(color = c('Red', 'White', 'White', 
                                   'White', 'Red', 'Red', 'White', 'Red', 'Red',
                                   'White'),
                         speed = c(10, 3, 8, 6, 12, 9, 3, 6, 7, 5))

boxplot(speed ~ color, data = car.speeds)
```

Here we see a function `data.frame` that creates a data object containing two other variables, `color`, a set of strings that we concatenate, and `speed`, a set of numbers that we concatenate.

Then we use the function `boxplot`.  `boxplot` takes a formula, and asks what data the formula is based on.  Here the formula says to plot a boxplot where speed is on the y axis and color is on the x axis.

All of this is fairly simple.  You can type it out yourself, but one of the strengths of R is that it can do these same operations on hundreds, or thousands of datasets by taking inputs from other sources.

Here we're going to look at NBA data from 2013. I downloaded the data from [here](http://www.basketball-reference.com/leagues/NBA_2013_totals.html), you'll find that there are lots of great places to find data online once you start looking.

There are 573 player entries, it's a big data set and I don't want to enter it myself. So we can take the data from the website and load it directly into R.  There are lots of ways to input and output data into R, and, as you explore more datasets you'll see there are lots of different data formats.  A good resource comes from the University of Notre Dame [here](http://www3.nd.edu/~sjones20/JonesUND/BioStats_files/Rinput%26output_1-15-13.pdf).

We're going to load the data, but first, take a look at it yourself by going [here]().   What sorts of variables do you see?  What's an interesting thing to look at?

```{r}
nba.data <- read.csv('data/nba_totals_2013.csv', stringsAsFactors = TRUE)

# Average age by team:
boxplot(Age ~ Tm, data = nba.data, cex.axis = 0.7)

boxplot(Age ~ Pos, data = nba.data)

boxplot(X2P ~ Tm, data = nba.data, cex.axis = 0.7)


```

So we've done some basic analysis with R.  Let's look at another way of getting data.

Websites like Twitter, Instagram or Facebook are really programs with input and output that come from and go to people's web browsers.  There are other ways to interface these programs, and they're called APIs, or Application Program Interfaces.  It is an interface between an application and a program.  In this case we'll look at Twitter, and try to interface Twitter with R.

R has a big user group, and people are interested in accessing all sorts of data.  Because of that the APIs for a number of programs have been translated into R code.  You can find more of them [here](http://cran.r-project.org/web/views/WebTechnologies.html) at the CRAN Web Technologies and Services task view.

Each of the packages in the task view are like smaller programs, with specific functions.  There are over 6000 contributed packages to R, so it doesn't make sense to install them all.  Most people use somewhere around 10 or 20 to do all of their analysis.  Because of this when we want to use a particular package we need to download it and install it.  Luckily, R can do that directly from the command line:

```{r}
install.packages('twitteR')
```

`twitteR` is one package that we can use to access twitter data from R.  Here the input comes not from a file, or manual entry, but directly from Twitter through its API.  Take a look at the help file for the [package](http://cran.r-project.org/web/packages/twitteR/twitteR.pdf).

Some APIs are free to use, some are more complicated and require pre-registration.  In the case of the Twitter API you need a special code.  For our purposes we'll use a common code that I'll give you directly.  It's hidden in a file called `unread.R`.  Because this tutorial is online I don't want everyone to have access to the API code so we'll just pretend it's there.  If you are doing this independently I found [this](http://bogdanrau.com/blog/collecting-tweets-using-r-and-the-twitter-search-api/) tutorial helpful for setting up the API and getting the key codes.  It also shows you how to do some more advanced analysis.

So let's look for a specific tweet.  I sent out a tweet the other day that used a nonsense hashtag, can the Twitter API find it?

```{r, eval=FALSE, echo=TRUE}

library(twitteR)
reqURL <- "https://api.twitter.com/oauth/request_token"
accessURL <- "https://api.twitter.com/oauth/access_token"
authURL <- "https://api.twitter.com/oauth/authorize"

#  This is where the keys are, but they're hidden.
source('R/unread.R')

twitCred <- OAuthFactory$new(consumerKey=consumerKey,
                             consumerSecret=consumerSecret,
                             requestURL=reqURL,
                             accessURL=accessURL,
                             authURL=authURL)

twitCred$handshake(ssl.verifypeer = FALSE) #Pause here for the Handshake Pin Code

registerTwitterOAuth(twitCred) #Wait till you see True

#  Takes about 1 min to register.
test_tweet <- searchTwitter("#bzlgrrrg", n=2000, ssl.verifypeer = FALSE) #Get the Tweets

```

Okay, this code should have worked and you should get a resonse that looks something like this:

```{r eval = FALSE, echo = FALSE}
Warning message:
In doRppAPICall("search/tweets", n, params = params, retryOnRateLimit = retryOnRateLimit,  :
  2000 tweets were requested but the API can only return 1
```

What does that one tweet look like?

```{r eval = FALSE, echo=TRUE}
test_tweet
```

Not much, but that's because the variable `test_tweet` is a special kind of variable, or `class`.  We've already seen `character` (the 'Red' and 'White' example) and `numeric` variable, there are lots of other classes, and each have special methods associated with them, one of which is `print`.

`print` is the function that prints things to the screen.  If you just type a variable name that invokes the `print` function.  You can find the `class` of a variable using the `class` function:

```{r}
class(test_tweet)
```